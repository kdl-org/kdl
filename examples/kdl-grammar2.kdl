/-kdl-version 2
Â§ "KDL Grammar" spec=(ğŸ”—)"github.com/kdl-org/kdl/blob/main/SPEC.md" !="See symbol defs at the bottom"\
document       	= bom? version? nodes                          	\
  version      	=â‰ /- uâ * "kdl-version" uâ + â¦… "1" | "2" â¦† uâ * â¤	\
  nodes        	=  â¦…l_â * nodeâ¦†* l_â *                           	\
    node       	=  node_base node_end                          	\
    node_chlast	=  node_base node_end?                         	\
      node_base	=â‰ /-? ğŸ„£? nâ * string                           	\
        â¦…nâ + /-? node_propâˆ¨arg  â¦†*                               \
        â¦…nâ + /-  node_children  â¦†*   !="Slashdashed node_children must be after props and args" \
        â¦…nâ +     node_children  â¦†?   !="Only children may follow a slashdashed child"           \
        â¦…nâ + /-  node_children  â¦†*                                                              \
        nâ *

Â§ "Entries"  	\
node_propâˆ¨arg	=  prop | argument                  	\
  prop       	=  string nâ * "=" nâ * ğŸ„£? nâ * value  	\
  argument   	=                     ğŸ„£? nâ * value  	\
    ğŸ„£        	=  "(" nâ * string nâ * ")"           	\
    value    	=  string | number | boolean | #null	\
node_children	=  "{" nodes node_chlast? "}"       	\
node_end     	=  comment_line | â¤ | ï¼› | eof

Â§ "Strings"               	                                                     	    \
string                    	 =  strğŸ†” | string'' | string_raw  Â¶                  	  \
  strğŸ†”                    	 =  cleanğŸ†” | signedğŸ†” | dottedğŸ†”                       	\
    cleanğŸ†”                	 =       â¦…â¦…charğŸ†” âˆ’ ã€”0â€“9ã€• âˆ’ Â± âˆ’ .â¦† charğŸ†”*â¦† âˆ’ keywordğŸ†”ğŸ›‘	  \
    signedğŸ†”               	 =  Â±    â¦…â¦…charğŸ†” âˆ’ ã€”0â€“9ã€•     âˆ’ .â¦† charğŸ†”*â¦†?           	    \
    dottedğŸ†”               	 =  Â±? . â¦…â¦…charğŸ†” âˆ’ ã€”0â€“9ã€•        â¦† charğŸ†”*â¦†?           	    \
      charğŸ†”               	 =  uchar âˆ’ uâ  âˆ’ â¤ âˆ’ charğŸ†”Â¬ âˆ’ charğŸ›‘                  	  \
      charğŸ†”Â¬              	 =  #"(;){"}[#]/=\"#                                 	    \
    keywordğŸ†”ğŸ›‘             	=  trueâ €|â €falseâ €|â €nullâ €|â €infâ €|â €-infâ €|â €nan            	  \
  string''                	 = â€œ                              â¦…     char_str âˆ’ â¤â¦†* â€   \
                          	|= â€œâ€œâ€œ                                                    \
                          	  â¦…â¤ deâ eâ‰¡ â¦…â€œ?â€œ? char_str âˆ’ â¤ - uâ â¦† â¦…â€œ?â€œ? char_str âˆ’ â¤â¦†* â¦†*	\
                          	  â¦…â¤       â¦…                    uâ â¦†*                    â¦†* 	\
                          	   â¤ deâ e* â€â€â€   !="deâ eâ‰¡ must exactly match deâ e; only required before non-whitespace" \
    char_str              	 =  charâ‹ | uniâ‹ | wâ â‹ | ã€”Â¬â§µâ€œã€• âˆ’ charğŸ›‘	\
      charâ‹               	 =  â§µ ã€”â€œâ§µbfnrtsã€•                      	    \
      uniâ‹                	 =  â§µ "u{" ucharâ‚â‚† "}"                	  \
        ucharâ‚â‚†           	 =  ã€”0â€“10FFFFã€• âˆ’ (surrogate)ã€”D800â€“DFFFã€• !="ranges in \u{F} format, but represented as hexâ‚â‚†, not actual symbols, so \u{B0} is 'B0', not 'Â°', can be 0-padded up to max len of 6"\
      wâ â‹                 	 =  â§µ â¦…uâ |â¤â¦†+	    \
    deâ e                  	 =  uâ  | wâ â‹ 	  \
  string_raw              	 = ï¼ƒ*â„•   string_raw_quoted                 ï¼ƒ*â„•â‰¡  !="â„•=1â€“âˆ  â„•â‰¡ must match â„•" \
    string_raw_quoted     	 =  â€œ     string_raw_body_line         â€                       	  \
                          	|=  â€œâ€œâ€œ â¤ string_raw_bodyâ˜°line â¤ deâ u* â€â€â€                     	  \
      string_raw_body_line	 = ""                                                          	  \
                          	|=      â¦…char_raw âˆ’ â€â¦† char_raw*?                              	  \
                          	|= â€œ    â¦…char_raw âˆ’ â€â¦† char_raw*?                              	  \
        char_raw          	 =         uchar âˆ’ â¤ âˆ’ charğŸ›‘                                   	\
      string_raw_bodyâ˜°line	 =  deâ uâ‰¡ â¦…uchar     âˆ’ charğŸ›‘â¦†*? !="â†deâ u must exactly match â‰¡â†‘"	  \
    deâ u                  	 =  uâ 

Â§ "Numbers (space in ã€”ã€• is ignored)" \
number     	  =  float_keyword | hex | octal | binary | decimal	  \
  hex      	  =      Â±?â €0x ğŸ”¢â‚â‚† â¦…_ | ğŸ”¢â‚â‚†â¦†*                      	\
  octal    	  =      Â±?â €0o ã€”0â€“7ã€•     ã€”0â€“7_ã€•*                   	  \
  binary   	  =      Â±?â €0b ã€”0â €1ã€•     ã€”0â €1_ã€•*                   	  \
  decimal  	  =      Â±? integer â¦…. integerâ¦†? â„¯?                	  \
    integer	  =            ã€”0â€“9ã€•     ã€”0â€“9_ã€•*                   	  \
    â„¯      	  = ã€”eEã€• Â±? integer                                	  \
           	                                                   	  \
  Â±        	  =     ã€”+-ã€•                                       	  \
  ğŸ”¢â‚â‚†      	=            ã€”0â€“9aâ€“fAâ€“Fã€•

Â§ "Keywords and booleans" \
keyword      	= boolean | #null       	\
float_keyword	= #inf    | #-inf | #nan	\
boolean      	= #true   | #false

Â§ "Specific code points" !="\u{0} unicode format is implied: ã€”u0ã€•=ã€”\u{0}ã€• ã€”Aâ€“Fã€•=ã€”\u{A}â€“\u{F}ã€• (range)" \
bom   	=  "\u{FEFF}" \
charğŸ›‘ 	=  (Â¬1st)"bom" (c0a)ã€”u0â€“u8ã€• (c0b)ã€”Eâ€“1Fã€• (cdel)ã€”7Fã€• (c_dir)ã€”200Eâ€“200Fâ €202Aâ€“202Eâ €2066â€“2069ã€• usvÂ¬ (ğŸ”—spec)"disallowed-literal-code-points" \
  usvÂ¬	=(surrogate)â‰ (high)ã€”D800â€“DBFFã€• (low)ã€”DC00â€“DFFFã€•  !="valid c0: ã€”u9â€“uDã€• 9â‰\t AâŠ\n Bâ‹\\v CâŒ\f Dâ\r" \
uchar 	=            ã€”0â€“D7FFâ €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €E000â€“10FFFFã€• !="Any Unicode Scalar Value (no surrogates)" \
uâ     	=  ã€”9â €20â €A0â €1680â €2000â €2001â €2002â €2003â €2004â €2005â €2006â €2007â €2008â €2009â €200Aâ €202Fâ €205Fâ €3000ã€•  !="Non line-breaking unicode White_Space" (ğŸ”—spec)"whitespace"\
      	  "	     Â   áš€     â€€    â€   â€‚    â€ƒ    â€„    â€…     â€†     â€‡    â€ˆ     â€‰     â€Š     â€¯   âŸ     ã€€  "\
uâ¤    	=  ã€”Aâ €Bâ €Câ €Dâ €85â €2028â €2029ã€•  !="(85NEL LS PS) Line-breaking unicode White_Space" (ğŸ”—spec)"newline" \
â€œ="\"" â€="\"" â§µ="\\" ï¼›=";" â„="/" *="âˆ—" ï¼ƒ="#"

Â§ "Comments (// /* */ after = serve as definition symbols)" \
/-               	  â‰  /- l_â *                            \
comment_block    	 =â‰  /* commented_block
  commented_block	 =   */                               	\
                 	|= â¦…comment_block | * | â„ | ã€”Â¬*â„ã€•+â¦†  ğŸ—˜	  \
comment_line     	 =â‰  // Â¬â¤* â¦…â¤ | eofâ¦†

Â§ "Whitespace" !="\u{F} unicode format is implied in ã€”Fã€• and ommited for brevity" \
l_â         	=  nâ  | â¤ | comment_line     !="Whitespace               where newlines are allowed" \
  nâ        	=  cuâ * escline cuâ * | cuâ +  !="Whitespace within nodes, where newline-ish things must be esclined" \
    cuâ     	=  uâ   |    comment_block           	\
    escline	= â§µ cuâ *    â¦…comment_line | â¤ | eofâ¦†	\
  â¤        	=  ã€”Dã€•ã€”Aã€• | uâ¤  !="ã€”Dã€•ã€”Aã€• \r\n ââŠ is a sequence, but counts as 1 newline" (ğŸ”—spec)"newline"

Â§ "Grammar language help: ABNF-like with some regex in a " rule="definition" "format" {
  â€¢ #"\â§µ "â€œ "â€ ;ï¼› /â„ *âˆ— #ï¼ƒ"#="literals represented with unicode alts to avoid quotes"
  â€¢ #"\  "    ; = "#="regular KDL syntax, not grammar"\
    #"  "x" "#="double quotes for literals" ##"  #"x"# "##="raw+double quotes for literals"\
    âˆ…=(empty)"" #"\"#=(text)"escape \" \\ or add â€˜ucharâ€™ in hex \u{FEFF}"\
    keys=(and_types)"extra group info" â‰="filler to allow /-comments in prop values"
  â€¢ |="logical OR"  !="tip/comment"  Â§="section marker"  ğŸ—˜="refers to self (rule name left of =)"
  â€¢â €Regexâ €matches                                                                                     	\
    ?â €="0|1 zero or one"                                                                              	\
    +â €="1+  one  or more (    greedy)"                                                                	\
    *â €="0+  zero or more (    greedy, match as many instances as possible)"                           	\
    *?="0+  zero or more (non-greedy, match as few  instances as possible; used only in raw strings)" 	\
    *1â€“6="    inclusive range: at least 1 at most 6"                                                  	\
    "0â€“9"="char range (inclusive)"  â€“="en-dash used to not blend with hyphen-minus in search"         	\
    Â¬="not this (^ in regex)" Â¬foo="must not match 'foo'"  ã€”Â¬â§µâ€œã€•=#"[^\"] any char except for \ or " "#	\
    ã€”setâ €ã€•="[a b]" #"set"#="[ab]" â‰="regex Char set matches like [], where any char will be a single match"\
    "â†‘ ignore â†‘ contained spaces (for visual separation or groups and alignment)"
    â¦…groupâ¦† "items must be matched together"\
    a|b="'a or b', whichever matches 1st. Multiple items before | are a single group" "a b c | d"="â¦…a b câ¦† | d"\
    â‰¡="defined to be identical to another similarly named match"
  â€¢ âˆ’="minus sign; 'except for' whatever follows it" "ucharâ €âˆ’â €â¤"="match â€˜ucharâ€™ rule, but not â€˜â¤â€™ rule"
  â€¢ Â¶="cut point: always matches and consumes no chars, but once matched, bans backtracking past that point in the source. If a parser would rewind past Â¶, it must instead fail the overall parse, as if it had run out of options (only for â€˜string_rawâ€™ to ensure the 1st instance of the appropriate closing quote sequence ends it)"
  â€¢ "A single definition may be split over multiple lines. Newlines are treated as spaces"
}
